/*快速幂算法可以减少求幂运算时的时间复杂度，并且当求幂运算的结果大于long long的最大范围，需要在中途对某一个值求mod时，可以运用快速幂算法
pow(a,i) 的时间复杂度为O(i),而快速幂算法的时间复杂度为O(logi)
*/
计算5^105,可以把它写成2的幂的和。
105 = 1+8+32+64= 2^0 + 2^3 + 2^5 + 2^6

二进制表示：
105       1 1 0 1 0 0 1
1         0 0 0 0 0 0 1
8         0 0 0 0 1 0 0
32        0 1 0 0 0 0 0
64        1 0 0 0 0 0 0
很明显，105的二进制表示中，每个位置上的1就代表了对应的2的幂数


const long long m=1e9+7;
long long quickpow(long long a,long long b){
	long long sum=1;
	while(b){
		if(b%2==1){//判断二进制最后一位是否为1
  		sum=sum*a%m;//取模运算  sum*a a依次为a的0次幂，1次幂，2次幂
  		a=a*a%m;
  		b>>=1;//位运算，右移，相当于除以2，更新二进制的最后一位数字
    }
	}
	return sum;
}
